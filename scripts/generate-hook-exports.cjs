/* eslint-disable */

/**
 * Generate Hook Exports Script
 *
 * Parses hooks/index.ts to find createContractHooks calls and generates
 * individual export files for each contract's hooks.
 *
 * Usage:
 *   node scripts/generate-hook-exports.cjs          # One-time generation
 *   node scripts/generate-hook-exports.cjs --watch  # Watch mode
 */

const { Project, SyntaxKind } = require("ts-morph");
const fs = require("fs");
const path = require("path");

const HOOKS_INDEX = path.join(
  __dirname,
  "../src/lib/contract-interactions/hooks/index.ts"
);
const HOOKS_DIR = path.join(
  __dirname,
  "../src/lib/contract-interactions/hooks"
);
const SRC_DIR = path.join(__dirname, "../src");

/**
 * Capitalize the first letter of a string
 */
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Convert ABI function name to hook name
 * e.g., "balanceOf" -> "useBalanceOf"
 */
function toHookName(fnName) {
  return "use" + capitalize(fnName);
}

/**
 * Resolve an import path like "@/lib/abi/..." to an absolute path
 */
function resolveImportPath(importPath) {
  if (importPath.startsWith("@/")) {
    return path.join(SRC_DIR, importPath.slice(2));
  }
  return path.join(HOOKS_DIR, importPath);
}

/**
 * Parse the index.ts file using AST and extract contract hooks info
 */
function parseIndexFile() {
  const project = new Project({
    compilerOptions: {
      baseUrl: SRC_DIR,
      paths: { "@/*": ["*"] },
    },
  });

  const sourceFile = project.addSourceFileAtPath(HOOKS_INDEX);

  const result = {
    abiImports: {}, // Map of ABI variable name to file path
    contractHooks: [], // Array of { name, abiVariable }
  };

  // Get all import declarations
  const importDeclarations = sourceFile.getImportDeclarations();
  for (const importDecl of importDeclarations) {
    const moduleSpecifier = importDecl.getModuleSpecifierValue();
    const namedImports = importDecl.getNamedImports();

    for (const namedImport of namedImports) {
      const importName = namedImport.getName();
      if (importName.endsWith("ABI")) {
        result.abiImports[importName] = moduleSpecifier;
      }
    }
  }

  // Get all variable declarations that use createContractHooks
  const variableStatements = sourceFile.getVariableStatements();
  for (const statement of variableStatements) {
    if (!statement.isExported()) continue;

    const declarations = statement.getDeclarations();
    for (const decl of declarations) {
      const initializer = decl.getInitializer();
      if (!initializer) continue;

      const initText = initializer.getText();
      if (initText.includes("createContractHooks")) {
        const name = decl.getName();

        // Extract the first argument (ABI variable) from the call
        const callExpr = initializer.asKind(SyntaxKind.CallExpression);
        if (callExpr) {
          const args = callExpr.getArguments();
          if (args.length > 0) {
            const abiVariable = args[0].getText();
            result.contractHooks.push({ name, abiVariable });
          }
        }
      }
    }
  }

  return result;
}

/**
 * Load an ABI file and extract function names
 */
function extractFunctionNames(abiFilePath) {
  if (!abiFilePath.endsWith(".ts") && !abiFilePath.endsWith(".js")) {
    abiFilePath += ".ts";
  }

  const absolutePath = resolveImportPath(abiFilePath);

  if (!fs.existsSync(absolutePath)) {
    console.error(`ABI file not found: ${absolutePath}`);
    return [];
  }

  // Read file and extract the array
  const content = fs.readFileSync(absolutePath, "utf-8");

  // Remove "export const XxxABI = " and "as const" to get raw array
  const arrayMatch = content.match(/=\s*(\[[\s\S]*\])\s*(as\s+const)?;?\s*$/);
  if (!arrayMatch) return [];

  // Eval the array (safe since it's our own ABI file)
  const abi = eval(arrayMatch[1]);

  // Filter functions and get names
  return abi
    .filter((item) => item.type === "function")
    .map((item) => item.name)
    .sort();
}

/**
 * Generate the content for a hook export file
 */
function generateExportFile(hookName, hookNames) {
  const hookExports = hookNames.map((name) => `  ${name}`).join(",\n");

  return `// Auto-generated by scripts/generate-hook-exports.cjs - DO NOT EDIT
import { ${hookName} } from "@/lib/contract-interactions/hooks";

export const {
${hookExports},
} = ${hookName};
`;
}

/**
 * Main generation function
 */
function generate() {
  console.log("Generating hook exports...");

  if (!fs.existsSync(HOOKS_INDEX)) {
    console.error(`Hooks index file not found: ${HOOKS_INDEX}`);
    process.exit(1);
  }

  const parsed = parseIndexFile();

  console.log(`Found ${parsed.contractHooks.length} contract hook(s)`);

  for (const { name, abiVariable } of parsed.contractHooks) {
    const abiPath = parsed.abiImports[abiVariable];

    if (!abiPath) {
      console.warn(`Could not find import for ABI: ${abiVariable}`);
      continue;
    }

    console.log(`Processing: ${name} (${abiVariable})`);

    const functionNames = extractFunctionNames(abiPath);
    const hookNames = functionNames.map(toHookName);

    console.log(`  Found ${hookNames.length} hooks`);

    if (hookNames.length === 0) {
      console.warn(`  No functions found in ABI, skipping...`);
      continue;
    }

    const outputPath = path.join(HOOKS_DIR, `${name}.ts`);
    const content = generateExportFile(name, hookNames);

    fs.writeFileSync(outputPath, content, "utf-8");
    console.log(`  Generated: ${outputPath}`);
  }

  console.log("Done!");
}

/**
 * Watch mode
 */
function watch() {
  console.log(`Watching ${HOOKS_INDEX} for changes...`);
  console.log("Press Ctrl+C to stop\n");

  // Initial generation
  generate();

  // Watch for changes
  let debounceTimer = null;
  fs.watch(HOOKS_INDEX, (eventType) => {
    if (eventType === "change") {
      // Debounce to avoid multiple rapid regenerations
      if (debounceTimer) {
        clearTimeout(debounceTimer);
      }
      debounceTimer = setTimeout(() => {
        console.log("\nFile changed, regenerating...\n");
        generate();
      }, 100);
    }
  });
}

// Main entry point
const isWatch = process.argv.includes("--watch");

if (isWatch) {
  watch();
} else {
  generate();
}
